<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 연산자 완벽 정리</title>
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; }
    h1 { color: #2c3e50; }
    h2 { color: #34495e; margin-top: 30px; }
    code { background: #f4f4f4; padding: 2px 5px; border-radius: 4px; display: block; margin: 5px 0; white-space: pre-line; }
    .example { background: #ecf0f1; padding: 10px; margin: 10px 0; border-left: 4px solid #3498db; }
    .note { color: #e74c3c; font-weight: bold; }
    .tip { color: #27ae60; font-weight: bold; }
  </style>
</head>
<body>
  <h1>JavaScript 연산자 완벽 정리</h1>
  <p>연산자란 <strong>값이나 변수에 특정 동작을 수행하는 기호</strong>입니다. 이 문서에서는 모든 주요 연산자를 기초 개념부터 예제 코드, 결과, 이유 설명까지 정리했습니다.</p>

  <h2>1. 대입 연산자 (=)</h2>
  <div class="example">
    <code>
let a = 5; 
console.log(a); // 5
// 이유: 오른쪽 값(5)을 왼쪽 변수(a)에 저장한다.
    </code>
  </div>
  <p class="note">헷갈리는 이유: '='를 '같다'로 착각</p>
  <p class="tip">안 헷갈리려면: '='는 대입, '=='는 비교</p>

  <h2>2. 산술 연산자 (+, -, *, /, %)</h2>
  <div class="example">
    <code>
console.log(5 + 3); // 8   → 덧셈
console.log(5 - 3); // 2   → 뺄셈
console.log(5 * 3); // 15  → 곱셈
console.log(10 / 3); // 3.333... → 나눗셈
console.log(10 % 3); // 1   → 나머지
// 이유: 각각 수학적 계산을 수행한다.
    </code>
  </div>
  <p class="note">헷갈리는 이유: %를 퍼센트로 착각</p>
  <p class="tip">안 헷갈리려면: %는 '나머지'</p>

  <h2>3. 증감 연산자 (++a, a++, --a, a--)</h2>
  <div class="example">
    <code>
// ++a : 전위 증가 → 먼저 증가 후 반환
let a = 5;
console.log(++a); // 6 (a가 6으로 증가한 뒤 반환)

// a++ : 후위 증가 → 현재 값 반환 후 증가
let b = 5;
console.log(b++); // 5 (현재 값 반환, 이후 b=6)
console.log(b);   // 6

// --a : 전위 감소 → 먼저 감소 후 반환
let c = 5;
console.log(--c); // 4 (c가 4로 감소한 뒤 반환)

// a-- : 후위 감소 → 현재 값 반환 후 감소
let d = 5;
console.log(d--); // 5 (현재 값 반환, 이후 d=4)
console.log(d);   // 4
    </code>
  </div>
  <p class="note">헷갈리는 이유: 반환 시점과 변경 시점이 다름</p>
  <p class="tip">안 헷갈리려면: '앞에 붙으면 먼저, 뒤에 붙으면 나중'</p>

  <h2>4. 비교 연산자 (==, !=, ===, !==, <, >, <=, >=)</h2>
  <div class="example">
    <code>
let x = 5, y = "5";

console.log(x == y);   // true
// 이유: ==는 값만 비교. "5"가 숫자 5로 변환되어 값이 같다고 판단.

console.log(x != y);   // false
// 이유: !=도 값만 비교. "5" → 5로 변환되어 값이 같으므로 '같지 않음'은 거짓.

console.log(x === y);  // false
// 이유: ===는 값과 타입 모두 비교. 값은 같지만 타입이 다름 (number vs string).

console.log(x !== y);  // true
// 이유: !==는 값과 타입 모두 비교. 값은 같아도 타입이 다르므로 '같지 않음'은 참.

console.log(5 > 3);    // true
// 이유: 5가 3보다 크므로 참.

console.log(5 <= 3);   // false
// 이유: 5는 3보다 작거나 같지 않으므로 거짓.
    </code>
  </div>
  <p class="note">헷갈리는 이유: JS 자동 형 변환</p>
  <p class="tip">안 헷갈리려면: 항상 ===와 !== 사용</p>

  <h2>5. 논리 연산자 (&&, ||, !)</h2>
  <div class="example">
    <code>
console.log(true && false); // false
// 이유: AND는 둘 다 참일 때만 true.

console.log(true || false); // true
// 이유: OR는 하나라도 참이면 true.

console.log(!true);         // false
// 이유: NOT은 반대값을 반환.
    </code>
  </div>
  <p class="note">헷갈리는 이유: &&와 ||를 영어 기호로 착각</p>
  <p class="tip">안 헷갈리려면: &&는 '그리고', ||는 '또는', !는 '아니다'</p>

  <h2>6. 조건(삼항) 연산자 (? :)</h2>
  <div class="example">
    <code>
let age = 20;
let result = (age >= 18) ? "성인" : "미성년자";
console.log(result); // "성인"
// 이유: 조건이 참이면 "성인", 거짓이면 "미성년자".
    </code>
  </div>

  <h2>7. Null 병합 (??)</h2>
  <div class="example">
    <code>
let name = null;
console.log(name ?? "익명"); // "익명"
// 이유: name이 null이므로 오른쪽 값 반환.

let count = 0;
console.log(count ?? 10); // 0
// 이유: 0은 null/undefined가 아니므로 그대로 반환.
    </code>
  </div>

  <h2>8. 옵셔널 체이닝 (?.)</h2>
  <div class="example">
    <code>
let user = null;
console.log(user?.name); // undefined
// 이유: user가 null이므로 에러 대신 undefined 반환.
    </code>
  </div>

  <h2>9. typeof</h2>
  <div class="example">
    <code>
console.log(typeof 123);   // "number"
console.log(typeof "hi");  // "string"
console.log(typeof null);  // "object"
// 이유: null은 JS 설계 오류로 object로 표시됨.
    </code>
  </div>

  <h2>10. delete</h2>
  <div class="example">
    <code>
let obj = {a:1, b:2};
delete obj.a;
console.log(obj); // {b:2}
// 이유: 객체 속성 a가 제거됨.
    </code>
  </div>

  <h2>11. in</h2>
  <div class="example">
    <code>
console.log("name" in {name:"효빈"}); // true
// 이유: 객체에 name 속성이 존재.

console.log(2 in [10,20,30]); // true
// 이유: 배열 인덱스도 속성으로 취급.
    </code>
  </div>

  <h2>12. instanceof</h2>
  <div class="example">
    <code>
let arr = [];
console.log(arr instanceof Array); // true
// 이유: arr은 Array로 생성된 객체.

console.log(123 instanceof Number); // false
// 이유: 123은 원시값이라 instanceof 불가.
    </code>
  </div>

    <h2>13. 할당 연산자 (+=, -=, *=, /=, %=)</h2>
  <div class="example">
    <code>
let x = 10;

x += 5;
console.log(x); // 15
// 이유: 기존 값 10에 5를 더해 다시 저장.

x -= 3;
console.log(x); // 12
// 이유: 기존 값 15에서 3을 빼서 다시 저장.

x *= 2;
console.log(x); // 24
// 이유: 기존 값 12에 2를 곱해 다시 저장.

x /= 4;
console.log(x); // 6
// 이유: 기존 값 24를 4로 나눠 다시 저장.

x %= 5;
console.log(x); // 1
// 이유: 기존 값 6을 5로 나눈 나머지를 다시 저장.
    </code>
  </div>
  <p class="note">헷갈리는 이유: 단순 대입과 혼동.</p>
  <p class="tip">안 헷갈리려면: '기존 값에 연산 후 저장'이라고 기억하기.</p>

  <h2>14. 전개 연산자 (...)</h2>
  <div class="example">
    <code>
let arr = [1,2,3];
let newArr = [...arr,4];
console.log(newArr); // [1,2,3,4]
// 이유: 기존 배열을 펼쳐서 새로운 배열에 복사 후 4 추가.

let obj = {a:1, b:2};
let newObj = {...obj, c:3};
console.log(newObj); // {a:1, b:2, c:3}
// 이유: 기존 객체 속성을 펼쳐서 새로운 객체에 복사 후 c 추가.
    </code>
  </div>
  <p class="note">헷갈리는 이유: rest 파라미터와 혼동.</p>
  <p class="tip">안 헷갈리려면: '...' 앞에 쓰이면 전개, 함수 매개변수에 쓰이면 rest.</p>

  <h2>15. 구조 분해 할당</h2>
  <div class="example">
    <code>
let [x,y] = [10,20];
console.log(x); // 10
console.log(y); // 20
// 이유: 배열의 각 요소를 변수에 순서대로 대입.

let {name, age} = {name:"효빈", age:20};
console.log(name); // "효빈"
console.log(age);  // 20
// 이유: 객체 속성 이름과 같은 변수에 값이 대입됨.
    </code>
  </div>
  <p class="note">헷갈리는 이유: 변수 이름과 속성 이름이 일치해야 한다.</p>
  <p class="tip">안 헷갈리려면: 구조 분해는 "이름 맞추기"라고 기억하기.</p>

  <h2>16. 비트 연산자 (&, |, ^, ~, <<, >>)</h2>
  <div class="example">
    <code>
console.log(5 & 3);  // 1
// 이유: 5(101) & 3(011) → 001 → 1

console.log(5 | 3);  // 7
// 이유: 5(101) | 3(011) → 111 → 7

console.log(5 ^ 3);  // 6
// 이유: 5(101) ^ 3(011) → 110 → 6

console.log(~5);     // -6
// 이유: 5(00000101)을 비트 반전 → 11111010 → -6 (2의 보수 표현)

console.log(5 << 1); // 10
// 이유: 5(101)을 왼쪽으로 1비트 이동 → 1010 → 10

console.log(5 >> 1); // 2
// 이유: 5(101)을 오른쪽으로 1비트 이동 → 10 → 2
    </code>
  </div>
  <p class="note">헷갈리는 이유: 논리 연산자(&&, ||)와 비슷해 보여서 혼동.</p>
  <p class="tip">안 헷갈리려면: 비트 연산자는 숫자를 2진수로 바꿔서 계산한다고 기억하기.</p>

  <h2>퀴즈로 연습하기 🎯</h2>
  <div class="example">
    <code>
Q1. let a = 5; console.log(a++); console.log(++a);
// 정답: 첫 출력은 5, 두 번째 출력은 7

Q2. let x = 5, y = "5"; console.log(x == y); console.log(x === y);
// 정답: true, false

Q3. console.log(true && false); console.log(true || false);
// 정답: false, true

Q4. console.log(null ?? "익명");
// 정답: "익명"

Q5. console.log(typeof null);
// 정답: "object"
    </code>
  </div>

</body>
</html>